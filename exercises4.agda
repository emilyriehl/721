{-# OPTIONS --without-K --exact-split --safe #-}

module exercises4 where
{-
Please rename your file to exercises4-yourusername.agda
-}

open import Agda.Primitive public
{-
open means we can access all definitions in Agda.Primitive
public means any file that imports this one gets Agda.Primitive too.
-}

UU : (i : Level) â†’ Set (lsuc i)
UU i = Set i

-- The one-sided identity type is the type family in context of a type A and term a : A freely generated by refl_a : Id a a.
data Id {i : Level}{A : UU i}(a : A) : A â†’ UU i where
    refl : Id a a

-- Definition 5.3.1: the application of functions on paths
ap : {i j : Level}{A : UU i}{B : UU j}{x y : A} â†’ (f : A â†’ B) â†’ (Id x y) â†’ (Id (f x) (f y))
ap f refl = refl 

-- Exercise: define a function componentwise-equality that proves that if two dependent functions
-- f g : (a : A) â†’ B a are identifiable then for all a : A the terms f a and g a are identifiable.
-- In summary: identifiable functions are "pointwise identifiable"
-- The converse implication does not hold in dependent type theory but does hold in homotopy type theory (as we will prove soon).

data Î£ {i j : Level}(A : UU i)(B : A â†’ UU j) : UU (i âŠ” j) where
    pair : (a : A) â†’ B a â†’ Î£ A B

pr1 : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ Î£ A B â†’ A
pr1 (pair x xâ‚) = x

pr2 : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ (z : Î£ A B) â†’ (B (pr1 z))
pr2 (pair x xâ‚) = xâ‚

-- product types are a special case of dependent pair types
_Ã—_ : {i j : Level} â†’ UU i â†’ UU j â†’ UU (i âŠ” j)
A Ã— B = Î£ A (Î» a â†’ B)

-- A and B are logically equivalent if the type "A â†” B" (type "\leftrightarrow") is inhabited
_â†”_ : {i j : Level} â†’ UU i â†’ UU j â†’ UU (i âŠ” j)
A â†” B = (A â†’ B) Ã— (B â†’ A)

-- Exercise: prove the type theoretic "axiom of choice" by defining a function
-- choice : {i j k : Level}{A : UU i}{B : UU j}{C : A â†’ B â†’ UU k} â†’ ((a : A) â†’ Î£ B (Î» b â†’ (C a b))) â†’ Î£ (A â†’ B)(Î» f â†’ ((a : A) â†’ (C a (f a))))

-- Challenge Exercise: state and prove a more general version of the type theoretic "axiom of choice" by defining an analogous function for types
-- {A : UU i}{B : A â†’ UU j}{C : (a : A) â†’ B a â†’ UU k}

-- Exercise: define a type family that asks whether a function is surjective
-- The curly braces {A = A}{B = B} are giving agda the names for some implicit arguments you will need to define this term.
-- is-surj : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU (i âŠ” j)

-- Exercise: define the type family that asks whether a function has a section 
-- Here f : A â†’ B has a section if there is some s : B â†’ A so that f (s b) = b for all b in B.
-- Warning: use the weaker "pointwise identifiable" notion to relate the functions f âˆ˜ s and id B.
-- has-section : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU (i âŠ” j)

-- Challenge Exercise: prove the axiom of choice, showing that a function is surjective iff it has a section

-- last time we called the empty type "empty" but today I prefer "âˆ…" (type "\emptyset")
data âˆ… : UU lzero where

Â¬_ : {i : Level} â†’ UU i â†’ UU i
Â¬ A = A â†’ âˆ…

ex-falso : {i : Level}{A : UU i} â†’ âˆ… â†’ A
ex-falso ()

-- last time we called the unit type "unit" but today I prefer "ğŸ™" (type "\b1")
data ğŸ™ : UU lzero where
    star : ğŸ™

-- type "\sqcup" for "âŠ”". This is a union of universe levels defined in Agda.Primitive
data coprod {i j : Level}(A : UU i)(B : UU j) : UU (i âŠ” j) where
    inl : A â†’ coprod A B
    inr : B â†’ coprod A B

-- Alternate notation for coproduct types
_+_ : {i j : Level}(A : UU i)(B : UU j) â†’ UU (i âŠ” j)
A + B = coprod A B

data bool : UU lzero where
    true false : bool

-- Exercise: show that bool is logically equivalent to the type ğŸ™ + ğŸ™ by defining three functions
-- bool-to-1+1 : bool â†’ ğŸ™ + ğŸ™

-- 1+1-to-bool : ğŸ™ + ğŸ™ â†’ bool

-- bool-iff-1+1 : bool â†” (ğŸ™ + ğŸ™)

-- Now we will characterize the identity type of bool
-- Exercise 6.2.a: define Eq-bool, observational equality on the booleans
-- Eq-bool : bool â†’ bool â†’ UU lzero

-- Exercise 6.2.b: show that Eq-bool is logically equivalent to the identity type of bool by defining three functions
-- eq-bool-to-id-bool : (s t : bool) â†’ ((Eq-bool s t) â†’ (Id s t))
-- id-bool-to-eq-bool : (s t : bool) â†’ ((Id s t) â†’ (Eq-bool s t))
-- eq-bool-iff-id-bool : (s t : bool) â†’ ((Eq-bool s t) â†” (Id s t))

neg-bool : bool â†’ bool
neg-bool true = false
neg-bool false = true

-- Exercise 6.2.c: define bool-neq-neg-bool proving that b â‰  neg-bool b for all booleans b
-- bool-neq-neg-bool : (b : bool) â†’Â Â¬(Id b (neg-bool b))

-- Exercise 6.2.c: define a term true-neq-false that concludes that true â‰  false

-- The transport function can be used to define a second proof that true â‰  false
tr : {i j : Level}{A : UU i}(B : A â†’ UU j){x y : A} â†’ (Id x y) â†’ (B x) â†’ (B y)
tr B refl b = b

Bool-In-World : bool â†’ UU lzero
Bool-In-World true = ğŸ™
Bool-In-World false = âˆ…

-- Exercise: use the transport function and the type family Bool-In-World to give a second proof that true â‰  false

-- Exercise: provide two proofs, "pf1" and "pf2", of the proposition {P Q : UU lzero} â†’ (P Ã— Q) â†’ (P + Q)

-- You can prove that pf1 â‰  pf2 by solving the following exercises

-- Challenge Exercise: prove that if pf1 = pf2 then inl star = inr star as terms of type ğŸ™ + ğŸ™
-- Hint: a term hyp : Id pf1 pf2 is really an equality between functions pf1 pf2 : (P Ã— Q) â†’ (P + Q)

-- Challenge Exercise: prove that if pf1 = pf2 then true = false as terms of type bool

-- Challenge Exercise: conclude that pf1 â‰  pf2

