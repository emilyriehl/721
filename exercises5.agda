{-# OPTIONS --without-K --exact-split --safe #-}

module exercises5 where
{-
Please rename your file to exercises5-yourusername.agda
-}

open import Agda.Primitive public
{-
open means we can access all definitions in Agda.Primitive
public means any file that imports this one gets Agda.Primitive too.
-}

UU : (i : Level) â†’ Set (lsuc i)
UU i = Set i

-- Preliminaries on dependent pair types; "\Sigma" for "Î£"
data Î£ {i j : Level}(A : UU i)(B : A â†’ UU j) : UU(i âŠ” j) where
    pair : (x : A) â†’ B x â†’ Î£ A B

pr1 : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ Î£ A B â†’ A
pr1 (pair x xâ‚) = x

_Ã—_ : {i j : Level}(A : UU i)(B : UU j) â†’ UU (i âŠ” j)
A Ã— B = Î£ A (Î» x â†’ B)

-- The one-sided identity type is the type family in context of a type A and term a : A freely generated by refl_a : Id a a.
data Id {i : Level}{A : UU i}(a : A) : A â†’ UU i where
    refl : Id a a

-- Definition 9.1.2: the type of homotopies "f âˆ¼ g" for a pair of dependent functions; type "\sim" for "âˆ¼"
-- The underscore in (x : _) is a reference to the implicit argument A.
_âˆ¼_ : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ (f g : (a : A) â†’ B a) â†’ UU(i âŠ” j)
f âˆ¼ g = (x : _) â†’ Id (f x) (g x)

-- Identities and composition; type "\circ" to get "âˆ˜"
id : {i : Level} (A : UU i) â†’ A â†’ A
id A a = a

_âˆ˜_ : {i j k : Level} {A : UU i} {B : UU j} {C : UU k} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
(g âˆ˜ f) a = g (f a)

-- Definition 9.2.1: equivalences as bi-invertible maps
sec : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
sec {A = A}{B = B} f = Î£ (B â†’ A) Î» s â†’ (f âˆ˜ s) âˆ¼ id B

retr : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
retr {A = A}{B = B} f = Î£ (B â†’ A) Î» r â†’ (r âˆ˜ f) âˆ¼ id A

is-equiv : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
is-equiv f = (sec f) Ã— (retr f)

-- Exercise: prove is-equiv-id, that the identity function defines an equivalence

-- Remark 9.2.6: the type of maps that have a two-sided inverse
has-inverse : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
has-inverse {A = A}{B = B} f = Î£ (B â†’ A)(Î» g â†’ ((f âˆ˜ g) âˆ¼ (id B)) Ã— ((g âˆ˜ f) âˆ¼ (id A)))

-- Exercise: prove that two-sided inverses define equivalences
-- is-equiv-has-inverse : {i j : Level}{A : UU i}{B : UU j}{f : A â†’ B} â†’ has-inverse(f) â†’ is-equiv(f)

-- Here are the path inversion and concatenation functions:
inv : {i : Level}{A : UU i}{x y : A} â†’ (Id x y) â†’ (Id y x)
inv refl = refl

_Â·_ : {i : Level}{A : UU i}{x y z : A} â†’ (Id x y) â†’ (Id y z) â†’ (Id x z)
refl Â· q = q

-- Exercise 9.1: prove is-equiv-inv, showing that (Î» (p : Id x y) â†’ inv p) is an equivalence
-- Hint: it might be useful to first define the homotopies you need

-- The type of equivalences between A and B; type "\simeq" for "â‰ƒ".
_â‰ƒ_ : {i j : Level} â†’ (A : UU i) â†’ (B : UU j) â†’ UU(i âŠ” j)
A â‰ƒ B = Î£ (A â†’ B)(Î» f â†’ is-equiv f)

-- Exercise 9.1: conclude that (Id x y) â‰ƒ (Id y x)
-- equiv-inv : {i : Level} {A : UU i} (x y : A) â†’ (Id x y) â‰ƒ (Id y x)

-- Definition 5.3.1: the application of functions on paths
ap : {i j : Level}{A : UU i}{B : UU j}{x y : A} â†’ (f : A â†’ B) â†’ (Id x y) â†’ (Id (f x) (f y))
ap f refl = refl
   
-- Definition 5.4.1: the transport function
tr : {i j : Level}{A : UU i}(B : A â†’ UU j){x y : A} â†’ (Id x y) â†’ (B x) â†’ (B y)
tr B refl b = b

-- Exercise 9.1: prove is-equiv-tr
-- is-equiv-tr : {i j : Level}{A : UU i}(B : A â†’ UU j){x y : A}(p : Id x y) â†’ is-equiv(Î» b â†’ (tr B p b))

-- Challenge Exercise 9.1: prove that the function concat p z defined below is an equivalence
-- Hint: you may want to copy the definitions of some of the coherence terms
-- concat : {i : Level}{A : UU i}{x y : A} (p : Id x y) (z : A) â†’ (Id y z) â†’ (Id x z)
-- concat p z q = p Â· q

data ğŸ™ : UU lzero where
    star : ğŸ™

-- Exercise (Example 9.2.9): prove right-unit-law-prod showing that (A Ã— ğŸ™) â‰ƒ A for any type A.
-- Hint: either pre-define the coherence homotopy you need or fill a hole with an expression of the form
-- "Î» {x â†’ ?}" and C_c C-space to create a new hole where the "?" appears. 
-- This allows you to type x into the new hole and case split.

data âˆ… : UU lzero where

data coprod {i j : Level}(A : UU i)(B : UU j) : UU (i âŠ” j) where
    inl : A â†’ coprod A B
    inr : B â†’ coprod A B

_+_ : {i j : Level} â†’ (A : UU i) â†’ (B : UU j) â†’ UU (i âŠ” j)
A + B = coprod A B 

-- Challenge Exercise (Example 9.2.9): prove right-unit-law-coprod that (A + âˆ…) â‰ƒ A
-- Hint: Either pre-define your terms or in a hole, type a function as "Î» {x â†’ ?}" and C-c C-space
-- to create a new hole in which you can case split the variable x.

-- Definition 10.1.1: is-contr A asserts that the type A is contractible
is-contr : {i : Level}(A : UU i) â†’ UU i
is-contr A = Î£ A (Î» a â†’ (x : A) â†’ (Id a x))

-- Exercise: show that any two points in a contractible type may be identified
-- contr-is-prop : {i : Level}{A : UU i} â†’ is-contr A â†’ (x y : A) â†’ (Id x y)

-- Challenge Exercise 10.1: Show that if A is contractible then for all x y : A the identity type Id x y is contractible
-- is-prop-is-contr : {i : Level}{A : UU i} â†’ (is-contr A) â†’ (x y : A) â†’ is-contr (Id x y)

terminal-map : {i : Level} â†’ (A : UU i) â†’ (A â†’ ğŸ™)
terminal-map A a = star

_â†”_ : {i j : Level} â†’ (A : UU i) â†’ (B : UU j) â†’ UU(i âŠ” j)
A â†” B = (A â†’ B) Ã— (B â†’ A)

-- Challenge Exercise 10.3.a: show is-contr A â†” is-equiv (terminal-map A) for types A : UU lzero


