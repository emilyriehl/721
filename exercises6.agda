{-# OPTIONS --without-K --exact-split --safe #-}

module exercises6 where
{-
Please rename your file to exercises6-yourusername.agda
-}

open import Agda.Primitive public
{-
open means we can access all definitions in Agda.Primitive
public means any file that imports this one gets Agda.Primitive too.
-}

UU : (i : Level) â†’ Set (lsuc i)
UU i = Set i

-- The one-sided identity type is the type family in context of a type A and term a : A freely generated by refl_a : Id a a.
data Id {i : Level}{A : UU i}(a : A) : A â†’ UU i where
    refl : Id a a

-- Definition 5.2.2: define "inv", the function that reverses paths
inv : {i : Level}{A : UU i}{x y : A} â†’ (Id x y) â†’ (Id y x)
inv refl = refl

_Â·_ : {i : Level}{A : UU i}{x y z : A} â†’ (Id x y) â†’ (Id y z) â†’ (Id x z)
refl Â· q = q

-- Definition 5.3.1: the application of functions on paths
ap : {i j : Level}{A : UU i}{B : UU j}{x y : A} â†’ (f : A â†’ B) â†’ (Id x y) â†’ (Id (f x) (f y))
ap f refl = refl

-- The transport function 
tr : {i j : Level}{A : UU i}(B : A â†’ UU j){x y : A} â†’ (Id x y) â†’ (B x) â†’ (B y)
tr B refl b = b

-- Definition 9.1.2: the type of homotopies "f âˆ¼ g" for a pair of dependent functions; type "\sim" for "âˆ¼"
-- The underscore in (x : _) is a reference to the implicit argument A.
_âˆ¼_ : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ (f g : (a : A) â†’ B a) â†’ UU(i âŠ” j)
f âˆ¼ g = (x : _) â†’ Id (f x) (g x)

_âˆ˜_ : {i j k : Level} {A : UU i} {B : UU j} {C : UU k} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
(g âˆ˜ f) a = g (f a)

-- Exercise: construct the whiskering operations on homotopies between non-dependent functions
-- _Â·r_ : {i j k : Level}{A : UU i}{B : UU j}{C : UU k} {f g : B â†’ C} â†’ (f âˆ¼ g) â†’ (h : A â†’ B) â†’ ((f âˆ˜ h) âˆ¼ (g âˆ˜ h))

-- _Â·l_ : {i j k : Level}{A : UU i}{B : UU j}{C : UU k} {f g : A â†’ B} â†’ (h : B â†’ C) â†’ (f âˆ¼ g) â†’ ((h âˆ˜ f) âˆ¼ (h âˆ˜ g))

-- Exercise: define the concatenation of homotopies
-- concat-htpy : {i j : Level}{A : UU i}{B : A â†’ UU j}{f g h : (x : A) â†’ B x} â†’ (f âˆ¼ g) â†’ (g âˆ¼ h) â†’ (f âˆ¼ h)

-- Preliminaries on dependent pair types; "\Sigma" for "Î£"
data Î£ {i j : Level}(A : UU i)(B : A â†’ UU j) : UU(i âŠ” j) where
    pair : (x : A) â†’ B x â†’ Î£ A B

pr1 : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ Î£ A B â†’ A
pr1 (pair a b) = a    

pr2 : {i j : Level}{A : UU i}{B : A â†’ UU j} â†’ (z : Î£ A B) â†’ B (pr1 z) 
pr2 (pair a b) = b 

_Ã—_ : {i j : Level}(A : UU i)(B : UU j) â†’ UU (i âŠ” j)
A Ã— B = Î£ A (Î» x â†’ B)

-- Identities and composition; type "\circ" to get "âˆ˜"
id : {i : Level} (A : UU i) â†’ A â†’ A
id A a = a

-- Definition 9.2.1: equivalences as bi-invertible maps
sec : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
sec {A = A}{B = B} f = Î£ (B â†’ A) Î» s â†’ (f âˆ˜ s) âˆ¼ id B

retr : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
retr {A = A}{B = B} f = Î£ (B â†’ A) Î» r â†’ (r âˆ˜ f) âˆ¼ id A

is-equiv : {i j : Level}{A : UU i}{B : UU j} â†’ (A â†’ B) â†’ UU(i âŠ” j)
is-equiv f = (sec f) Ã— (retr f)

-- The type of equivalences between A and B; type "\simeq" for "â‰ƒ".
_â‰ƒ_ : {i j : Level} â†’ (A : UU i) â†’ (B : UU j) â†’ UU(i âŠ” j)
A â‰ƒ B = Î£ (A â†’ B)(Î» f â†’ is-equiv f)

is-contr : {i : Level} â†’ (A : UU i) â†’ UU i
is-contr A = Î£ A (Î» a â†’ ((x : A) â†’ Id a x))

-- Exercise: show that if A â‰ƒ B and B is contractible then A is contractible
-- is-contr-equiv-contr : {i j : Level}{A : UU i}{B : UU j} â†’ (A â‰ƒ B) â†’ is-contr B â†’ is-contr A

-- Exercise: show that any function between contractible types is an equivalence
-- is-equiv-is-contr : {i j : Level} {A : UU i}{B : UU j} â†’ (is-contr A) â†’ (is-contr B) â†’ (f : A â†’ B) â†’ is-equiv f

-- Section 12.3 general truncation levels
data ğ•‹ : UU lzero where
  neg-two-ğ•‹ : ğ•‹
  succ-ğ•‹ : ğ•‹ â†’ ğ•‹

-- Exercise: define is-trunc, a function which takes a truncation level k : ğ•‹ and a type A to the type is-trunc k A

-- Exercise: define is-prop using is-trunc

-- Challenge Exercise 10.1 from the previous assignment defines is-prop-is-contr below using eq-is-contr and left-inv  
eq-is-contr : {i : Level}{A : UU i} â†’ is-contr A â†’ (x y : A) â†’ (Id x y)
eq-is-contr (pair c h) x y = (inv (h x)) Â· h y

left-inv : {i : Level}{A : UU i}{x y : A} â†’ (p : Id x y) â†’ Id ((inv p) Â· p) refl
left-inv refl = refl

-- This is commented out because is-prop has not yet been defined
-- Once you solve the previous exercise (and define is-prop) uncomment the next two lines because you'll need it very soon
-- is-prop-is-contr : {i : Level}{A : UU i} â†’ (is-contr A) â†’ (is-prop A)
-- is-prop-is-contr (pair c h) x y = pair (eq-is-contr (pair c h) x y) (Î» { refl â†’ left-inv (h x) } ) 

-- Exercise (Proposition 12.4.3): prove if A is k-truncated then A is k+1-truncated
-- is-trunc-succ-is-trunc : {i : Level}{A : UU i}(k : ğ•‹) â†’ is-trunc k A â†’ is-trunc (succ-ğ•‹ k) A

-- The aim of the next series of exercises is to prove a logical equivalence between
-- is-prop, all-elements-equal, and is-proof-irrelevant
all-elements-equal : {i : Level} â†’ UU i â†’ UU i
all-elements-equal A = (x y : A) â†’ (Id x y)

is-proof-irrelevant : {i : Level} â†’ UU i â†’ UU i
is-proof-irrelevant A = A â†’ is-contr A

-- Exercise: prove that is-prop implies all-elements-equal
-- all-elements-equal-is-prop : {i : Level} {A : UU i} â†’ is-prop A â†’ all-elements-equal A

-- Exercise: prove that all-elements-equal implies is-proof-irrelevant
-- is-proof-irrelevant-all-elements-equal : {i : Level}{A : UU i} â†’ all-elements-equal A â†’ is-proof-irrelevant A

-- Challenge Exercise: prove that is-proof-irrelevant implies is-prop
-- is-prop-is-proof-irrelevant : {i : Level}{A : UU i} â†’ is-proof-irrelevant A â†’ is-prop A

-- type "\sqcup" for "âŠ”". This is a union of universe levels defined in Agda.Primitive
data coprod {i j : Level}(A : UU i)(B : UU j) : UU (i âŠ” j) where
    inl : A â†’ coprod A B
    inr : B â†’ coprod A B

data âˆ… : UU lzero where

Â¬_ : {i : Level} â†’ UU i â†’ UU i
Â¬ A = A â†’ âˆ…

data ğŸ™ : UU lzero where
    star : ğŸ™

-- Challenge Exercise 12.4(a): Show that if A and B are contractible types then A + B is not contractible
-- Hint: transport in a suitably defined type family can help produce a term of type âˆ… 
-- is-not-contr-coprod-is-contr : {i j : Level}{A : UU i}{B : UU j} â†’ is-contr A â†’ is-contr B â†’ Â¬ (is-contr (coprod A B))
